## 函数定义 & 调用

- 普通函数
- 可变函数
- 箭头函数

```php
<?php
// function 函数名(参数列表[可选]) {
//  函数体
//  返回值[可选]
// }
function sayHi($name) {
  echo "Hi {$name}";
}

sayHi("tom"); // Hi tom


// 匿名函数(或者叫闭包): 在 PHP 的手册教程中的中文翻译称之为: "可变函数"
// https://www.php.net/manual/zh/functions.variable-functions.php
$sayHello = function($name) {
  echo "Hello {$name}";
}; // 注意了赋值语句行尾必须加上 ;
$sayHello("jerry"); // hello jerry



// 注意点:
// 0. 定义箭头函数需要用关键字 fn(参数) => 返回值
// 1. 箭头函数只能写一行(类似 Python 的 lambda 表达式)
// 2. 箭头函数的作用域永远是父级作用域(类似 JS 箭头函数的 this 指向)
$n = 1;
$increment = fn($step) => $n + $step;
$x = $increment(5);
var_dump($x); // int(6)
```

箭头函数是 php 7.4 的新语法,

- [查看官方文档](https://www.php.net/manual/zh/functions.arrow.php)

## 判断是否可调用

其实也就是判断: 是否是一个函数(只有函数才可以调用呀)

```php
<?php

function f1() {}
$f2 = function() {};

// 注意是传入函数名字符串, 而不是直接将函数传入
var_dump(is_callable('f1')); // bool(true)
var_dump(is_callable($f2)); // bool(true) 注意: 匿名函数需要直接传入变量
var_dump(is_callable('$f2')); // bool(false) 否则无法检测出来会返回 false
var_dump(is_callable('f2')); // bool(false)  否则无法检测出来会返回 false
var_dump(is_callable('f3')); // bool(false) 检测不存在的函数, 不会报错, 会返回 false
```

## 魔法常量 `__FUNCTION__`

`__FUNCTION__` 在哪个函数中使用, 它的值就是那个函数的函数名

```php
<?php
function sayHi($name) {
  echo __FUNCTION__ . " hello {$name}";
}
sayHi("tom"); // sayHi hello tom

echo "<hr />";

$sayHello = function($name) {
  echo __FUNCTION__ . " hello {$name}";
};
$sayHello("jerry"); // {closure} hello jerry
```

## 函数的参数

::: code-group

```php [多个参数]
<?php
function sum($n1, $n2, $n3) {
  return $n + $n2 + $n3;
}
```

```php [可选参数/带有默认值的参数]
<?php
function sayHi($name = "tom") {
  echo "Hi {$name}";
}
```

```php [传递引用而不复制值的参数]
<?php

echo "<pre>";

// 值传递
function pop_last($arr) {
  return array_pop($arr);
  // array_pop 函数的作用就是: 将数组的最后一个元素弹出,
  // 和 JS Array.prototyp.pop() 方法功能一模一样
}
$arr1 = ['a', 'b', 'c'];
$res1 = pop_last($arr1);
var_dump($arr1); // 原数组不变 ['a', 'b', 'c']
var_dump($res1); // c

echo "<hr />";

// 引用传递(指针传递/内存地址传递)
// 在C语言中, 指针是一种数据类型, 它指向一个
// 内存地址, 而且 & 符号就是取内存地址的意思
function pop_last2(&$arr) {
  return array_pop($arr);
}
$arr2 = ['a', 'b', 'c'];
$res2 = pop_last2($arr2);
var_dump($arr2); // 原数组被修改 ['a', 'b']
var_dump($res2); // c
echo "</pre>";
```

:::

## 函数返回值

1. 只能返回一个值
2. 默认返回 `NULL`

```php
<?php
function f1() {
  // echo 是输出到缓冲区,可不是函数返回值
  echo "hello<br/>";
}

function f2() {
  // return 关键字才是结束函数并返回数据的
  return "hello";
}

$res1 = f1();
var_dump($res1); // NULL

$res2 = f2();
var_dump($res2); // string(5) hello
```

## 作用域

### 超全局作用域

在任意PHP文件中都能够访问的变量/常量, 只有内置的变量/常量能做到这一点

```php
<?php
// a.php
var_dump($_SERVER);
>

<?php
// b.php
var_dump($_SERVER);
?>
```

### 全局作用域

在变量定义所在文件中, 整个文件有效

```php
<?php

$num = 10;
function f1() {
  // 默认情况下: 在函数内部无法访问
  // global 关键字的作用:
  //   1. 如果全局作用域有 $num 就将使用全局作用域的 $num
  //   2. 如果全局作用域没有 $num, 则会在全局作用域创建一个 $num
  global $num;
  var_dump($num);
}
f1();

$f2 = function() use($num) {
  // 默认情况下: 在函数内部无法访问
  // 可以使用 use 关键字告诉解释器, 我要访问全局变量
  // 但是: use 只能用作匿名函数, 不能用于 function 定义的函数
  // 这样写是不行的: function f1() use($num) { }
  var_dump($num);
};

$f2();
```

### 函数作用域

仅在函数体中有效

```php
<?php

function f1() {
  $num = 10;
}
// 这样是不行的, 无法访问函数内部的变量
// var_dump($num);


function f2() {
  global $num;
  $num = 10;
}
// 这样是不行的, 无法访问函数外部的变量
// var_dump($num);


// 这样是可以的:
// 因为 f2 一旦执行:
//   1. $num 就会被标记为全局变量
//   2. $num(全局变量) 被赋值为 10
f2();
var_dump($num); // int(10) => 3. 所以这里会输出 int(10)



function f3() {
  $num = 10;
  global $num;
  echo "f3 num: $num";
}
f3();
var_dump($num); // NULL 请问: 为什么会输出 NULL?

/*
为什么会输出 NULL?

1. f3函数执行:
  1.1) $num = 10;   是局部变量赋值为10, 在函数内部的变量(是函数作用域)
  1.2) global $num; 看全局是否有 $num 变量, 没有, 则创建一个全局变量 $num, 但是后续并没有给这个全局变量赋值
  1.3) echo "f3 num: $num"; 执行, 输出字符串, 注意: 此时的 $num 是局部变量, 所以值是 10
2. 执行 var_dump($num); 由于创建了全局变量 $num, 但是并没有赋值, 所以输出 NULL
*/
```

## 函数相关的处理方法

https://www.php.net/manual/zh/book.funchand.php
