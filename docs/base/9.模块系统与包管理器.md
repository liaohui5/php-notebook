## 模块系统?

由于PHP开发的时间比较早, 那时可能还没有模块化开发的概念
都是类似C语言那种在一个文件中直接 `include` 另外一个文件进来

## 直接导入文件

在一个php文件中导入另外一个php文件内容, 就称之为导入模块

在php中导入模块主要以下几个方法

| 语句           | 文件不存在时           | 重复包含     | 适用场景                       |
| -------------- | ---------------------- | ------------ | ------------------------------ |
| `include`      | 产生警告，继续执行     | 允许重复包含 | 可选内容，如页面组件、模板     |
| `include_once` | 产生警告，继续执行     | 禁止重复包含 | 可选的函数库、辅助文件         |
| `require`      | 产生致命错误，停止执行 | 允许重复包含 | 必需的关键文件，无重复定义风险 |
| `require_once` | 产生致命错误，停止执行 | 禁止重复包含 | 必需的类定义、核心函数库       |

## 命名空间

### 什么是命名空间？

命名空间是 PHP 用于 `解决名称冲突` 问题。它将代码划分为不同的"区域", 使相同名称的类、函数、常量可以在不同命名空间中共存。

### 为什么要使用命名空间？

- 避免类/函数/常量名称冲突(尤其是使用多个第三方库时)
- 便于自动加载机制实现

### 声明命名空间

```php
<?php
// 声明一个命名空间（必须在文件最开始，除了declare语句外）
namespace MyProject;

class MyClass {
    public function test() {
        echo "MyProject\\MyClass";
    }
}

// 使用该命名空间中的类
$obj = new MyClass(); // 等同于 new \MyProject\MyClass()
```

### 多级命名空间

```php
<?php
namespace MyProject\SubNamespace;

class Database {
  // 类定义
}
```

### 命名空间的解析规则

```php
<?php

new MyClass();            // 在当前命名空间中查找
new Sub\MyClass();        // 在当前命名空间下的Sub子空间中查找
new \MyProject\MyClass(); // 从全局空间开始查找
```

## use 导入

### 基本导入

```php
<?php
namespace MyApplication;

// 导入并可以使用别名
use MyProject\Database;
use MyProject\Logger as AppLogger; // 使用别名

$db = new Database(); // 等同于 new \MyProject\Database()
$logger = new AppLogger(); // 等同于 new \MyProject\Logger()
```

### 导入函数和常量

```php
<?php
// 导入函数
use function MyProject\Utils\debug_function;

// 导入常量
use const MyProject\Constants\MAX_SIZE;

debug_function();
echo MAX_SIZE;
```

### 批量导入 (PHP 7+)

```php
<?php
use MyProject\{Database, Logger, Cache};
use function MyProject\Utils\{debug_function, helper_function};
```

### 访问全局空间

```php
<?php
namespace MyProject;

// 访问全局空间的类
$exception = new \Exception();

// 访问全局函数
\array_map(function() { /*...*/ }, []);

// 全局常量
echo \PHP_VERSION;
```

## 类的自动加载

PHP提供了自动加载机制，避免手动包含大量类文件。

```php
<?php
// 传统方式 - 不推荐
// require_once 'classes/User.php';
// require_once 'classes/Database.php';

// 使用spl_autoload_register注册自动加载函数
spl_autoload_register(function ($class) {
  // 将命名空间分隔符替换为目录分隔符
  $file = str_replace('\\', DIRECTORY_SEPARATOR, $class) . '.php';

  // 添加基础目录
  $file = __DIR__ . DIRECTORY_SEPARATOR . 'src' . DIRECTORY_SEPARATOR . $file;

  // 检查文件是否存在
  if (file_exists($file)) {
    require_once $file;
    return true;
  }

  return false;
});

// 使用命名空间的类
use MyApp\Models\User;
use MyApp\Database\Connection;

// 这些类会在使用时自动加载
$user = new User();
$db = new Connection();

// PSR-4自动加载示例
// 目录结构:
// project
// └── src
//     └── MyApp
//         ├── Models
//         │   └── User.php
//         └── Database
//             └── Connection.php

// User.php内容:
// <?php
// namespace MyApp\Models;
// class User { /* ... */ }

// Connection.php内容:
// <?php
// namespace MyApp\Database;
// class Connection { /* ... */ }
```

## 包管理器 composer

Composer 是PHP的依赖管理工具, 它允许你声明项目所依赖的库, 并自动管理(安装/更新)
这些依赖, 类似于Node.js 的 npm 或 Rust 的 cargo

- [搜索需要的依赖](https://packagist.org/)

### 安装

- [download-composer-for-windows](https://github.com/composer/windows-setup/releases/tag/v6.3.0) 下载并运行

```sh
# linux or MacOS
curl -sS https://getcomposer.org/installer | php
mv composer.phar /usr/local/bin/composer

# 验证
composer --help
```

### 核心命令

```sh
# 1.初始化(会创建 composer.json/composer.lock/src/vender)
mkdir phpdemo && cd -
composer init

# 2.安装模块
composer require monolog/monolog # 2.1 安装新的第三方模块
composer install  # 2.2 根据 composer.json/composer.lock 中的内容安装需要的模块

# 3.更新模块
composer update # 3.1更新所有模块
composer update monolog/monolog # 3.2仅更新 monolog/monolog 这个模块

# 4.移除模块
composr remove monolog/monolog # 删除 monolog/monolog 这个模块

# 5.搜索模块, 也可以去 https://packagist.org/ 找
composer search laravel # 搜索模块名包含 laravel 的

# 6.直接创建一个项目(类似 npm 根据模板创建项目)
composer create-project topthink/think tp-demo
# 在当前目录下创建一个 tp-demo 的目录, 并且这是一个带有 ThinkPHP 框架文件的项目
```
